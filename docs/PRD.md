Правила, команди та навички для Agentic IDE
Вступ
Генеративний штучний інтелект стрімко увійшов у сферу розробки, пропонуючи інструменти на
кшталт GitHub Copilot та Roo Code для прискорення написання коду. Ідея Agentic IDE полягає в
інтеграції AI-агентів безпосередньо в середовище розробки, щоб вони могли автономно
виконувати багатоетапні завдання, планувати зміни, генерувати код і навіть відлагоджувати
програму. Це новий рівень можливостей для розробників: AI може виступати як напарникпрограміст або навіть як команда агентів з різними ролями . У цій доповіді ми розглянемо, як
підготувати свій проєкт та IDE для максимально продуктивної співпраці з великими мовними
моделями (LLM) і кодогенеруючими AI-агентами. Особливу увагу приділимо плагінам Roo Code
та GitHub Copilot у Visual Studio Code, які втілюють концепцію Agentic IDE.
Мета доповіді – надати практичні рекомендації junior/middle розробникам щодо налаштування
середовища та використання концепцій rules (правил), commands (команд), skills (навичок),
режимів (modes), AI-інструкцій і промптів. Ми розглянемо, що означають ці поняття, як їх
налаштувати для кожного проєкту, як керувати та оновлювати ці налаштування, а також
розкажемо про best practices при написанні правил і навичок. Теоретичну частину підкріпимо
двома практичними прикладами: налаштування проєкту з Roo Code та з GitHub Copilot у VS
Code.
Налаштування середовища для роботи з LLM-агентами
Перший крок до продуктивної роботи з генеративним ШІ – правильно налаштувати
середовище розробки. Розглянемо основні кроки:
Встановлення AI-помічника. У VS Code є декілька розширень Agentic IDE. Ми
зосередимось на двох популярних:
Roo Code – відкритий AI-асистент у вигляді VS Code-плагіну, що діє як ціла команда
розробників-агентів .
GitHub Copilot – пропрієтарний AI-помічник від GitHub (на базі моделей OpenAI),
інтегрований у VS Code для доповнення коду та чату.
Аутентифікація та доступ до моделей. Copilot працює “із коробки” після входу в GitHub
та активації підписки. Натомість Roo Code є модель-незалежним: після встановлення
потрібно підключити AI-провайдера (наприклад, OpenAI API чи OpenRouter) та ввести APIключ . Roo Code підтримує десятки моделей різних постачальників (OpenAI,
Anthropic, Google Vertex тощо) і навіть локальні моделі – ви обираєте, з якою працювати
. Це робить Roo Code гнучким і майбутньостійким, адже ви не прив’язані до єдиного
модельного API .
Індексація коду (контекст). Щоб LLM ефективно розуміла ваш проєкт, важливо надати їй
доступ до коду. Copilot автоматично використовує відкриті файли та інші файли в
репозиторії як контекст. Roo Code додає до цього можливість індексувати кодову базу для
семантичного пошуку: ви можете ставити питання на кшталт "How is authentication
handled?" і агент знайде відповідні ділянки коду . Переконайтеся, що індексація
1
•
•
2 3
•
•
4 5
6
7
•
8 9
1
ввімкнена та налаштована (наприклад, вибрано провайдер ембеддінгів та поріг схожості) –
це покращить здатність AI знаходити потрібну інформацію у вашому коді .
Контроль дій AI. Робота з агентами в IDE вимагає балансу між автономністю і контролем.
Roo Code дозволяє налаштувати, які дії агент може виконувати автоматично, а які
потребуватимуть вашого схвалення. За допомогою налаштувань auto-approve ви можете,
наприклад, дозволити дрібні правки коду проходити автоматично, але вимагати
підтвердження для небезпечних дій (видалення файлів, виконання shell-команд тощо) .
Такий гранульований контроль допомагає уникнути небажаних “сюрпризів” від надто
самостійного AI . Copilot менш автономний за природою – він не виконує довільних дій,
тож подібних налаштувань там немає, але принцип той самий: перевіряйте всі
пропозиції AI перед прийняттям змін до коду.
Оновлення та версії. Слідкуйте за оновленнями розширень. Roo Code активно
розвивається (open-source, часті релізи) – оновлення можуть додавати режими або
покращувати якість. Copilot теж отримує нові функції (наприклад, Copilot Chat, Copilot CLI).
Тримайте інструменти актуальними, щоб користуватися останніми можливостями та
виправленнями безпекових проблем.
Надалі перейдемо до ключових концепцій Agentic IDE – правил, режимів, інструкцій, промптів,
навичок та команд – і розглянемо їх налаштування.
Правила (Rules) та AI-інструкції
Одним з найважливіших аспектів роботи з AI-агентом є формування для нього правильних
“рамок поведінки”. Для цього служать правила – спеціальні інструкції, що задають стиль
кодування, стандарти та обмеження для AI. По суті, правила – це кастомні налаштування
системного промпту, які завжди присутні у контексті моделі.
У Roo Code поняття правил реалізоване через механізм Custom Instructions. Ви можете створювати
глобальні правила (діють у всіх проєктах) або правила робочої області (в межах конкретного
проєкту) . Правила зберігаються у текстових файлах Markdown або TXT: - Глобальні
правила: папка ~/.roo/rules/ – інструкції, які застосовуються до всіх проєктів за
замовчуванням . Тут ви можете прописати універсальні настанови: стандарт оформлення коду,
правила безпеки, стилістичні уподобання тощо. - Правила проєкту: папка <project>/.roo/
rules/ у корені репозиторію – специфічні для даного проєкту вказівки . Вони мають
пріоритет над глобальними (якщо є конфлікт) . Це дозволяє підлаштовувати AI під вимоги
конкретної кодової бази. Наприклад, в одному проєкті ви можете вимагати документування
кожної функції, а в іншому – дотримуватися MVC-архітектури. - Правила для режимів: окремо
можна визначати інструкції для конкретного режиму Roo Code, створивши папку .roo/rules-
{mode}/ (наприклад .roo/rules-code/ для режиму написання коду) . Це тонке
налаштування: наприклад, у режимі Debug дозволити більше діагностичних виводів, а в режимі
Code – наголосити на чистоті коду.
Що можна прописувати у правилах? Будь-що, що спрямовує модель відповідати вашим
очікуванням. Приклади: - Кодстайл: «Використовувати 4 пробіли для відступів, дужки відкривати
на тій самій строкі»; - Конвенції: «Завжди додавати docstring до публічних методів. Коментарі –
англійською мовою.»; - Технології: «Для звернення до БД використовувати тільки SQLAlchemy, сирі
SQL-запити заборонені.»; - Обмеження: «Не видаляти файли без дозволу. Не використовувати
небезпечні функції, як eval .».
Правила допомагають вирівняти поведінку AI з практиками вашої команди. Як зазначають
розробники, Copilot чи інший асистент “не читає ваші думки”, тому йому треба явно задати
10 11
•
12
12
•
13 14
15
16
17 18
19
2
контекст і очікування . Встановивши файл з інструкціями, ви надаєте AI своєрідні «знання
проекту», які команда набуває з досвідом . Особливо корисно прописати: - Огляд проєкту:
коротко, що за застосунок, для кого, основні функції (щоб AI розумів цілі) . - Технічний
стек: мови, фреймворки, БД, інфраструктура, які використано, з особливостями налаштування
(наприклад, «Node.js + Express, базу MongoDB керуємо через Mongoose») . - Керівництво
по кодстайлу та практиках: домовленості по форматуванню, використанню типів, написанню
тестів, безпеці тощо (наприклад: «завжди використовуй типи TypeScript; ніколи не залишай
console.log у PR»). Такі правила можуть бути оформлені списком для чіткості . - Структура
проекту: опиши, як організовано репозиторій – які папки за що відповідають. Це економить час
моделі на розуміння, де що лежить (інакше вона буде гадати з контексту) . - Інші ресурси:
наприклад, наявність скриптів або команд для запуску, тестування, деплою, щоб AI міг їх
згадувати або використовувати (якщо агент може виконувати shell-команди) .
Для GitHub Copilot зовсім недавно з’явився подібний механізм налаштувань: файл інструкцій
для репозиторію. Якщо у корені проекту створити файл .github/copilot-instructions.md ,
Copilot буде читати його при кожному запиті в Copilot Chat або при генеруванні коду агентом .
Таким чином, ви можете задати Copilot-у все те саме (огляд, стек, гайдлайнз), що й у випадку Roo
Code. Як показує практика, Copilot “краще працює, коли має правильний контекст, майже як новий
член команди”, якому ви пояснили, над чим працюєте і яких правил дотримуватися . Цей
файл – ключ до того, щоб Copilot пропонував рішення, які пасують саме вашому проєкту.
Best practices для написання правил/інструкцій: - Не залишайте AI без вказівок. Навіть
мінімальний набір правил кращий, ніж їх повна відсутність. Неповний або “неідеальний” файл
інструкцій все одно дасть відчутний ефект – надалі його можна покращувати . - Будьте
конкретними, але лаконічними. Інструкції повинні бути чіткими. Уникайте розмитих фраз на
кшталт “пиши якісний код” – краще вкажіть, що саме для вас означає якість (наприклад, «код має
проходити ESLint без попереджень»). - Структуруйте та розбивайте на секції. Використовуйте
заголовки: “Огляд”, “Стек”, “Стиль коду”, “Структура” тощо. Це підвищує читабельність інструкцій (і
для колег, і опосередковано для моделі) . - Охоплюйте ключові аспекти проекту.
Переконайтеся, що згадані всі мови та технології, які ви використовуєте, щоб AI розумів контекст.
Згадайте навіть нетипові інструменти (напр. “Використовуємо власний форк фреймворку X” –
інакше модель може запропонувати несумісний код). - Оновлюйте правила в процесі. Так само,
як документація, ваші AI-інструкції мають підтримуватися в актуальному стані по мірі розвитку
проекту . Додаєте новий модуль чи бібліотеку – відобразіть це в правилах. Виявили, що AI
неправильно розуміє задачу – допишіть пояснення або нове правило. - Уникайте конфліктних
або занадто жорстких правил. Якщо правил буде надто багато і вони суперечитимуть одне
одному, модель може розгубитися. Задавайте пріоритети: що критично (безпека, стиль), а де
можна імпровізувати. Не намагайтеся повністю “скувати” творчість AI – нехай правила задають
напрям, але не диктують кожен крок.
Режими (Modes) агентів
Однією з визначальних особливостей Roo Code є наявність кількох режимів роботи AI-агента,
кожен з яких заточений під певну роль. Ідея в тому, що великий мовний модель можна обмежити
рамками конкретного завдання, щоб вона менше «галюцинувала» та точніше виконувала свою
роль . Roo Code з коробки пропонує декілька рольових режимів (Modes) :
Architect – режим архітектора. Агент вивчає вимоги, планує реалізацію, пропонує дизайн
рішень, але не вносить зміни в код. Фактично, це режим для обдумування: складання
списку завдань, проектування модулів і API, оцінки потенційних змін. Architect Mode
20
21
22 23
24 25
26 27
28
29
30
20 21
31
32 26
31
33 3
•
3
працює тільки на читання файлів, без права запису , тому він безпечний для
початкового етапу – ніяких руйнувань коду, тільки плани.
Code – режим кодера. Агент безпосередньо пише код, змінює файли, рефакторить. У цьому
режимі доступні всі інструменти: читання та редагування файлів, виконання команд у
терміналі, використання зовнішнього браузера/API тощо . Саме в Code Mode Roo Code
реалізує більшість функцій автогенерації і редагування.
Debug – режим відлагодження. Агент аналізує помилки, логи, виконує тестування та
пропонує виправлення. Він має спеціальні вбудовані інструкції для пошуку причин багів:
модель намагається розбити проблему на гіпотези, додати логування, перевірити кожну
гіпотезу – і лише потім внести виправлення . Агент у Debug Mode також може запускати
тести чи скрипти, якщо потрібно відтворити помилку.
Ask – режим «питань та відповідей». У цьому режимі агент виступає як довідник: відповідає
на запитання щодо коду, пояснює, як працює та чи інша функція, наводить приклади
використання. Важливо, що Ask Mode не змінює код, а значить його можна безпечно
використовувати для навчання і дослідження прямо в IDE (аналог ChatGPT, але з
контекстом вашого проекту) .
Test – (якщо наявний) режим для написання та оптимізації тестів. Агент генерує модульні
чи інтеграційні тести, перевіряє покриття, не змінюючи основний код програми. Це зручно
для збільшення надійності: ви можете попросити згенерувати тести для нового модуля.
Orchestrator – спеціальний режим для багатокрокових завдань (так звані boomerang
tasks). Він може координувати інші режими: розбивати велику задачу на підзадачі,
призначати їх різним агентам (Planner, Coder, Reviewer тощо) і об'єднувати результат
. Цей режим більше використовується в Roo Code Cloud (коли кілька агентів працюють
спільно у хмарі над задачами), але локально Orchestrator Mode теж може інколи
перемикати контекст.
Custom – користувацькі режими, які ви можете створити самі. Roo Code дозволяє
визначати свої режими, задаючи їм власні системні інструкції, обмеження по інструментах,
іконку та назву . Наприклад, можна зробити режим SQL Assistant для написання
лише SQL-запитів або режим UX Writer для генерування текстів інтерфейсу. Ці режими
можуть бути глобальними чи специфічними для проекту . Доступний навіть
маркетплейс з шаблонами режимів від спільноти Roo Code .
Як розробнику використовувати режими? Режим обирається в Roo Code з випадаючого списку
внизу вікна або через slash-команди /ask , /code , /debug тощо . Важливо перед
початком роботи над задачою усвідомлено перейти в відповідний режим. Наприклад, якщо
ви тільки сформулювали вимоги до фічі – варто почати з Architect Mode, щоб отримати план дій і
список файлів для зміни. Потім перейти в Code Mode для реалізації, і якщо виникають баги –
переключитися в Debug Mode для їх виправлення. Такий підхід (планування перед кодингом)
запобігає тому, щоб модель одразу «кидалася писати код» без розуміння контексту – що часто
призводить до технічного боргу та помилок . Режими дозволяють уникати цих проблем,
фокусуючи AI на поточному завданні та відсікаючи зайве. Як зазначено у документації, кожен
режим має обмеження на інструменти і зону відповідальності, тому модель не береться робити
те, що не належить до її ролі . Більш того, Roo Code досить «розумний», щоб сам
пропонувати переключити режим, якщо запит виходить за рамки поточного. Приклад: ви
перебуваєте в Code Mode, але задали питання «Чому ця функція падає?» – агент може попросити
дозволу перейти в Debug Mode, щоб краще відповісти .
GitHub Copilot не має явних режимів, подібних до Roo Code, – його поведінка більш уніфікована.
Однак у Copilot можна умовно виділити: - Copilot Inline (автодоповнення коду в реальному часі) –
коли ви пишете код або коментар, і Copilot пропонує продовження. - Copilot Chat – окремий чатпанель, де можна задавати запитання чи давати інструкції (аналог режиму Ask/Debug, залежно
34
•
34
•
35
•
36
•
•
37
38
•
39 40
41
42
43
44 45
46 47
48
4
від того, що спитаєте). - Copilot for PRs – режим рецензування pull request’ів (у веб-інтерфейсі
GitHub), де Copilot виступає як Code Reviewer, пропонуючи зауваження і навіть виправлення. Це
дещо схоже на окремого агента-рев’ювера. - Copilot CLI/Terminal – додатковий інструмент (в
Windows Terminal або через npm-пакет), що приймає природномовні команди та конвертує їх у
shell-команди. Це можна розглядати як ще один вузький режим (для DevOps-завдань).
Проте всі ці прояви Copilot працюють на основі однієї й тієї ж моделі і не потребують від
користувача перемикати режими вручну. Copilot сам визначає, як відповісти (кодом чи
поясненням) залежно від запиту. Це простіше, але менш гнучко: ви не можете, наприклад,
заборонити Copilot виконувати певні дії, бо він і так не виконує їх автономно. Якщо потрібна
функціональність, подібна до різних ролей (планувальник, налагоджувач), – у Copilot доводиться
реалізовувати це через явні промпти (наприклад: «Draft a step-by-step plan for adding a new
feature» – щоб Copilot виступив архітектором, або «Find the bug in this code» – щоб він спробував
відлагодити).
Практична порада: навіть без режимів, ви можете застосовувати концепцію режимності в роботі
з Copilot. Спочатку попросіть у Copilot Chat загальний план або запитайте пояснень – перш ніж
просити написати код. Так ви імітуєте підхід Roo Code: спершу обдумати (Copilot надасть текстову
відповідь), потім реалізувати (використати його ж або написати коментар з описом функції, щоб
Copilot згенерував код). Такий розділений підхід допомагає отримати більш структурований
результат і краще зрозуміти, що саме буде робити згенерований код.
Промпти та формулювання запитів
Промпт (prompt) – це будь-який запит або команда, яку ви даєте AI-моделі. Правильне написання
промптів – ключова навичка для ефективної роботи з Coding AI. В контексті IDE це може бути: -
Повідомлення у чаті Roo Code або Copilot Chat (наприклад: “Згенеруй функцію, яка перевіряє
валідність email”). - Коментар у коді, на основі якого Copilot генерує продовження (наприклад:
// TODO: add error handling for network failures і очікування, що AI допише
реалізацію). - Виклик slash-команди (в Roo Code), яка по суті теж підставляє заздалегідь
заготовлений промпт. - Опис PR або commit message, згенерований AI (це теж різновид промпту
до моделі, просто контекст інший).
Як правильно ставити запит LLM, щоб отримати корисний результат? Ось кілька
рекомендацій: - Чітко сформулюйте завдання. Модель не здогадується про ваші наміри, якщо
вони не озвучені. Поганий промпт: “Напиши програму для роботи з БД”. Кращий: “Напиши функцію
на Python, яка підключається до PostgreSQL, робить SELECT запит до таблиці users і повертає
результат у форматі JSON”. Ще краще додати деталі: “...використовуючи бібліотеку psycopg2, з
обробкою винятків на випадок помилки з'єднання”. - Розбийте складне завдання на підзадачі.
Якщо вам потрібно реалізувати велику фічу, не просіть все одним промптом. Спочатку – хай агент
створить план (список кроків). Потім ідіть крок за кроком: реалізація кожного підпункту окремо.
Це особливо актуально в Copilot, бо він генерує менші шматки коду. У Roo Code теж ефективніше
працювати ітеративно, ніж однією гігантською командою. - Використовуйте контекстні
підказки. Обидва інструменти вміють враховувати ваш код. Copilot автоматично бачить зміст
поточного файлу і сусідніх. Roo Code дозволяє явно посилатися на файли або символи
(@назва_функції) у промпті, щоб модель їх прочитала . Наприклад, якщо ви просите змінити
функцію, вкажіть її назву або вставте її код у запит – так агент матиме необхідний контекст. -
Задавайте формат відповіді, якщо потрібно. Хочете, щоб AI згенерував тільки код без
пояснень? Скажіть: “виведи лише код без коментарів”. Потрібен опис алгоритму – попросіть “поясни
кроки вирішення”. Форматування (JSON, Markdown) теж варто уточнювати, якщо це важливо. -
49
5
Експериментуйте з перефразуванням. Якщо AI не зрозумів або згенерував щось не те,
спробуйте переформулювати запит. Додайте деталей або навпаки спростіть. LLM-и іноді краще
реагують на інший порядок слів чи контекст. - Обережно з відкритими завданнями. Питання
на зразок “що ти про це думаєш?” можуть призвести до розлогих міркувань моделі не по темі.
Намагайтеся, щоб кожен промпт мав конкретну мету: згенерувати код, знайти баг, пояснити
фрагмент, тощо.
Особливості написання промптів для Roo Code: - Ви можете використовувати режими як частину
інструкції: в Architect Mode краще формулювати запити на кшталт “Сплануй, як додати функціонал
реєстрації користувачів”. Агент видасть список кроків чи план роботи. Потім у Code Mode можна
написати: “Реалізуй крок 1 з плану: створення моделі User в ORM”. Такий контекст (посилання на
попередній план) збереже послідовність дій. - Roo Code підтримує інструменти (tools) –
наприклад, read_file , write_file , new_task тощо, які агент може викликати при потребі
. Вам не потрібно явно про них писати у промпті (агент сам вирішує), але ви побачите їх у діях.
Якщо агент просить дозволу відкрити URL чи виконати скрипт – оцініть доцільність, перш ніж
підтвердити.
Особливості Copilot Chat промптів: - Copilot Chat має кнопки з підказками (suggested prompts) на
основі контексту. Їх можна використовувати як шаблон, але не соромтеся редагувати, щоб запит
відповідав вашій ситуації. - Враховуйте, що контекст Copilot обмежений певним вікном (звичайно
до ~4k токенів для старих моделей, ~8k або більше для нових). Якщо файл дуже великий, Copilot
може бачити тільки частину його. Тому в чаті може бути корисно скопіювати важливий уривок
коду у ваш промпт вручну. - Copilot не пам’ятає історію довго – кожен новий файл чи сеанс чату
частково ізольований. В Roo Code ж історія діалогу зберігається протягом сесії, особливо якщо
використовувати режим Orchestrator (він координує довгі діалоги). Отже, у Copilot Chat інколи
доведеться нагадувати інформацію, яку ви давали раніше (якщо вона вийшла за межі
контекстного вікна).
Нарешті, завжди аналізуйте відповіді AI критично. Якщо щось виглядає підозріло – перепитайте
або перевірте самі. Обидва інструменти можуть переконливо “фантазувати”. Хороший розробник
використовує AI як помічника, але остаточні рішення приймає сам.
Навички (Skills) в Roo Code
Одне з потужних розширень можливостей Roo Code – це навічки (Skills). Навичка – це, по суті,
пакет інструкцій і допоміжних матеріалів під конкретне завдання, який AI-агент може
динамічно підключати, коли цей пакет актуальний. Концепція навичок дозволяє додати моделі
глибоке знання в окремій вузькій галузі, не “засмічуючи” її базовий контекст постійно .
Чому виникла потреба в skills? Раніше ми говорили про глобальні правила, які постійно в
контексті. Але якщо у вас є дуже специфічна задача, наприклад обробка PDF-файлів, немає сенсу
тримати інструкції про це весь час в системному промпті – вони знадобляться лише коли ви
дійсно працюєте з PDF. Навички якраз вирішують цю проблему: вони діють “за вимогою”. Ви
створюєте окрему навичку з описом “як парсити PDF”, і Roo Code автоматично підвантажить її
лише тоді, коли ваш запит відповідає тематиці PDF . Таким чином, базовий промпт
залишається компактним, а модель отримує додаткові вказівки лише для релевантних завдань
– що і ефективніше (менше токенів), і безпечніше (менше шансів, що AI змішає в одне правила
для різних доменів) .
49
50
51
50 52
6
Як створити навичку: Це робиться шляхом додавання спеціальної папки і файлу в проект (або
глобально): 1. Придумайте назву навички і її призначення. Наприклад, pdf-processing для
роботи з PDF, api-docs-generator для генерації документації API тощо. 2. Створіть папку
навички: - Для глобальної навички (щоб була доступна в усіх проектах): ~/.roo/skills/
<назва_skill>/SKILL.md . - Для проектної навички: <project>/.roo/skills/
<назва_skill>/SKILL.md . 3. У файлі SKILL.md опишіть frontmatter з метаданими та
основний контент інструкцій. Мінімум, що потрібно у frontmatter – це name (назва навички) і
description (опис, коли її слід застосовувати) . Опис дуже важливий: саме за нього Roo Code
визначає, коли активувати навичку . Наприклад:
---
name: pdf-processing
description: Extract text and tables from PDF files using Python libraries
---
# PDF Processing Instructions
When the user requests PDF processing:
1. Check if PyPDF2 or pdfplumber is installed
2. For text extraction, use pdfplumber for better table detection
3. For simple text-only PDFs, PyPDF2 is sufficient
4. Always handle encoding errors gracefully
5. Offer to save extracted content to a file
## Code Template
... (шаблони коду, приклади) ...
## Common Issues
- Encrypted PDFs: Explain they require password parameter
- Scanned PDFs: Recommend OCR tools like pytesseract
- Large files: Suggest page-by-page processing
В цьому прикладі навичка містить чіткі інструкції та поради, як працювати з PDF: які бібліотеки
використовувати, як обробляти типові проблеми (шифровані чи відскановані PDF, великі файли)
. Коли ви запитаєте у чаті щось на кшталт “Витягни таблиці з PDF-файлу”, Roo Code
розпізнає, що це стосується PDF, і автоматично підвантажить ці інструкції в контекст . 4.
Додатково, у папці навички можна покласти пов’язані файли: скрипти, шаблони, дані. У нашому
прикладі це міг би бути файл extract.py з готовими функціями для парсингу PDF, або теку
templates/ з шаблоном звіту . Навичка може посилатися на ці ресурси, і Roo Code дозволить
агенту їх читати при виконанні (таким чином ви як би даєте моделі наперед заготовлений код для
виконання частини роботи) . Це ще один плюс навичок – можливість пакувати з
інструкціями ще й код чи дані, чого не зробиш у простих правилах . 5. Перевірте, що
навичка працює: задайте запит, який має її активувати, і спостерігайте, чи Roo Code завантажив її.
У логах Roo (режим debug UI) буде видно, як спрацював механізм навичок (рівні Discovery/
Instructions/Resources) .
Особливі можливості навичок: - Навички можуть бути прив’язані до режиму. Якщо ви хочете,
щоб навичка діяла тільки в певному режимі Roo Code, можна створити її в папці з суфіксом
режиму. Наприклад, .roo/skills-code/refactoring-patterns/SKILL.md – тоді ця навичка
активується лише в Code Mode . Це зручно, коли, скажімо, ви маєте набір патернів
рефакторингу: немає сенсу, аби вони завантажувалися в режимі Architect чи Debug. Аналогічно,
53
54
55
56 57
58 59
56 60
61
62
62
63 64
65 66
7
для режиму Architect можна зробити навички зі схемами дизайну, для режиму Test – навички зі
специфікою написання тестів тощо. - Пріоритети та переваги: якщо однакова навичка (з тим
самим ім’ям) існує глобально і в проекті, то проектна заміняє глобальну . Якщо є варіант
загальний і режим-специфічний – то режим-специфічний має пріоритет, коли ви в тому режимі
. Це логіка, подібна до правил: локальне переважає над глобальним, а спеціалізоване – над
загальним. Така ієрархія дозволяє мати базові глобальні навички, але перевизначати їх під
потреби конкретного проекту при необхідності .
Best practices для skills: - Формулюйте description так, щоб вона однозначно відповідала
певному наміру користувача. Не варто робити занадто загальну навичку з описом «web
development help», яка може помилково спрацьовувати на будь-який веб-запит. Краще кілька
вузьких навичок (наприклад, “React hooks best practices”, “Django ORM migrations” тощо). -
Слідкуйте, щоб навички не конфліктували з основними правилами. Якщо в глобальних
інструкціях написано «не використовувати бібліотеку X», а в навичці ви раптом радите її
використати – це заплутає модель. У такому випадку, скоріш за все, варто коригувати саме
правила або робити виключення явно. - Версіонуте навички у репозиторії. Папку .roo/
skills/ доцільно додати в контроль версій, особливо якщо над проектом працює команда. Так
усі отримають ці спеціалізовані знання AI. Більше того, навички – це код і документація, їх можна
проходити code review, покращувати, коментувати. Це новий артефакт проекту, який підлягає
командній співпраці. - Перевикористовуйте глобальні навички. Якщо ви виробили класну
навичку (скажімо, “генерування API документації” з шаблонами), поставте її глобально, щоб у
нових проектах одразу мати її в арсеналі. Roo Code дозволяє зібрати бібліотеку особистих навичок
у ~/.roo/skills/ . - Тестуйте та оновлюйте. Подібно до правил, навички слід
підтримувати: коли змінюються інструменти або підходи, оновіть інструкції. Переконайтеся, що
інструкції навички актуальні під нові версії бібліотек, інакше AI може генерувати застарілий код.
Slash-команди (кастомні команди)
Ще один інструмент підвищення продуктивності в Roo Code – це slash-команди (від символу
"/" , з якого вони викликаються). Slash-команди дають змогу створювати короткі текстові
тригери для часто виконуваних або багатокрокових запитів, перетворюючи їх на команду одним
словом. Фактично це схоже на макроси або шорткати для AI: ви пишете / і назву команди, а Roo
Code підставляє заздалегідь підготовлений сценарій (промпт) замість вас .
Навіщо це потрібно? Уявімо, що ви кожен день просите AI виконати рев’ю коду на одні й ті самі
критерії. Замість щоразу друкувати довгий список ("Please review code for performance issues,
security vulnerabilities, code style violations, potential bugs"), ви можете один раз оформити це як
команду /review . Тоді будь-коли, набравши /review , ви миттєво викличете свій шаблон
перевірки . Це економія часу і забезпечення стандартності – вся команда використовує
однакові перевірки.
Створення кастомної команди: 1. Файл команди. Команди зберігаються у вигляді Markdownфайлів. Ім’я файлу визначає ім’я команди: - Файл deploy-check.md стане командою /deploycheck . - Файл test-api.md → команда /test-api , і т.д. . Файли можна зберігати
глобально ( ~/.roo/commands/ ) або в конкретному проекті ( .roo/commands/ в репозиторії)
. Проектні команди мають пріоритет над глобальними, якщо ім’я співпадає . 2. Зміст
файлу. У найпростішому випадку – це просто текст підказки, який має вставитися. Наприклад,
review.md може містити:
67
68
69 70
71 72
73 74
75 76
75 77
78 79
8
Please review this code for:
- Performance issues
- Security vulnerabilities
- Code style violations
- Potential bugs
Як результат, /review в чаті розгорнеться у цей текст автоматично . Ви можете одразу
відправити його агенту на виконання. 3. Розширені можливості. Файл команди може містити
frontmatter з метаданими для додаткової функціональності: - description: короткий опис, що буде
видно у меню команд (щоб ви чи колеги розуміли, що робить команда) . - argument-hint:
якщо команда потребує аргумент від користувача (наприклад, назву файлу або ім’я модуля), тут
можна зазначити підказку, що саме очікується . Тоді в списку команд після назви буде сірим
текстом показано формат аргументу. При виборі команди, вона вставиться, і курсор чекатиме
введення аргументу. - mode: можна зазначити режим Roo Code, в який слід автоматично
переключитися перед виконанням команди (e.g. mode: architect або mode: code ) . Це
дуже зручно: наприклад, команда /review може одразу перевести агента в Reviewer Mode
(якщо ви створили окремий режим рев’ю) або просто в режим Ask, щоб він нічого не змінював, а
лише читав код.
---
description: Comprehensive code review focusing on security and performance
argument-hint: <file or directory to review>
mode: debug
---
# Security-First Code Review
(... шаблон рев’ю з чеклістом безпеки ...)
В цьому прикладі команда /review матиме опис, очікуватиме аргумент (шлях до файлу/папки) і
завжди переходить у Debug Mode для виконання (щоб агент не редагував код, а лише аналізував)
. 4. Керування командами. Roo Code надає зручний інтерфейс у налаштуваннях: на вкладці
Slash Commands ви можете створювати нові команди, редагувати або видаляти їх . При
створенні через UI, вам достатньо ввести ім’я – і плагін сам створить файл-шаблон з потрібною
структурою. 5. Використання. У чаті почніть вводити /(слеш) – відкриється меню доступних
команд з автодоповненням і описами . Можна прокрутити список або набрати кілька літер для
фільтрації. Виберіть потрібну команду – вона підставиться в поле вводу; далі допишіть аргумент
(якщо потрібно) і надішліть запит. Все, агент отримує повний промпт з команди.
Приклади корисних slash-команд: - /run-tests – команда, яка в режимі Terminal виконує
скрипт тестування і збирає результати (Roo Code дозволяє агенту запускати shell-команди, тому
можна автоматизувати таку рутинну дію). - /docstring – генерує шаблон DocString для
виділеної функції, з описом параметрів та повернення. - /schema-update <model_name> –
прочитує файл з описом моделі і генерує міграцію для БД (команда може поєднати читання файлу
моделі та написання нового файлу). - /translate <lang> – перекладає виділений текст коду
коментарів або документації на вказану мову (корисно для локалізації). - /quick-fix – в режимі
Debug бере останнє повідомлення про помилку (з консолі) і намагається знайти та виправити
причину у коді.
Важливо, що такі команди теж можна зберігати у репозиторії і ділитися з командою – це сприяє
стандартизації робочих процесів. Всі розробники матимуть однакові швидкі команди для
76
80 81
82 81
83
84
85
86
9
типових задач, що зменшує ймовірність людської помилки і економить час . Замість того,
щоб кожен згадував, які кроки треба зробити для деплою, можна викликати /deploy-check і
бути впевненим, що AI виконає стандартизований набір перевірок.
Примітка: GitHub Copilot наразі не підтримує користувацькі команди як такі. Однак у Copilot існує
поняття Prompt Files – по суті, схоже на slash-команди, але для Copilot Chat. Це файли, які можна
створити, щоб зберегти довгі промпти і викликати їх потім швидко у чаті (доступні через
інтерфейс Copilot Labs або VS Code). Вони також можуть бути спільними для команди. Таким
чином, хоча Copilot не має прямої функції /commands , аналогічної Roo Code, ви можете досягти
схожого результату, створюючи шаблони запитів і звертаючись до них за потреби (наприклад,
тримаючи текст в окремому файлі і копіюючи в чат). Невдовзі, ймовірно, екосистема Copilot
забезпечить більш тісну інтеграцію подібних сценаріїв (вже є згадки про «Custom Agents» та
можливість запускати складніші послідовності дій).
GitHub Copilot: можливості та обмеження
Перейдемо детальніше до GitHub Copilot – інструмента, який, хоча і не є “агентним” у повному
розумінні, проте надзвичайно популярний як AI-помічник розробника. Для багатьох це перший
досвід взаємодії з генеративним AI в коді.
Що робить Copilot: - Пропонує кодові доповнення у реальному часі. Коли ви пишете код або
коментар, Copilot аналізує контекст (до 100-200 рядків навколо курсора, плюс пов’язані файли) і
генерує декілька можливих продовжень. Ви бачите їх “привидами” (greyed-out text) і можете
прийняти Tab-ом. Це прискорює написання однотипного коду, запобігає помилкам при
друкуванні тощо. - Відповідає на запити в Copilot Chat. У VS Code є окрема панель Copilot (якщо
ви включені у технічний прев’ю Copilot Chat або використовуєте Copilot X). Там ви можете
спілкуватися з Copilot, як з чат-ботом, задаючи питання про ваш код, просити генерувати
фрагменти, пояснювати помилки, створювати тести. Copilot Chat має доступ до вашого відкритого
проекту, тому знає про класи, функції і навіть може виконувати “думки” (analysis) на кшталт
пошуку певного патерну у вашому коді. - PR та код рев’ю. Якщо увімкнути Copilot for Pull
Requests, AI може читати діффи і коментувати зміни: знаходити потенційні баги, пропонувати
додати тести або документацію. Це дуже корисно для навчання менш досвідчених розробників,
коли AI підказує кращі практики прямо в код рев’ю. - Copilot CLI (окремо). Набір інструментів, що
дозволяє запитувати, яку команду shell виконати для певної задачі, або генерувати find / grep
команди за описом. Це більше для DevOps-навантаження і виходить за межі VS Code, але варто
знати, що Copilot екосистема розширюється.
Наскільки Copilot “agentic”? На відміну від Roo Code, Copilot не виконує довільних
багатокрокових дій. Він не буде сам планувати і змінювати файли, якщо ви його про це явно не
попросите. В інтерактивному режимі (чаті) Copilot здатен реагувати на ваші інструкції послідовно,
але ініціатива завжди за вами. Немає такого, що Copilot сам переключиться між ролями чи почне
виконувати shell-команди. Усі зміни в коді він пропонує або як diff, або як новий файл, але ви їх
маєте затвердити вручну (просто вставляючи згенерований код в редактор).
Це означає, що Copilot простіший і безпечніший на старті – менший ризик, що “щось піде не
так” без вашого відома. З іншого боку, функціонально він обмежений: якщо ви скажете “створи
мені новий модуль з такими-то файлами”, Copilot не зможе створювати файли сам по собі чи
масово редагувати різні частини проекту. Вам доведеться робити це поетапно.
87 88
10
Налаштування Copilot для проєкту: - Встановіть розширення GitHub Copilot у VS Code і
виконайте логін в GitHub. Переконайтеся, що у вас є доступ (для приватних репо потрібна
підписка Copilot for Individuals або ліцензія Copilot for Business, якщо компанія надала). -
Увімкніть Copilot Chat (за потреби). Станом на 2025 рік Copilot Chat – функція, що може
вимагати окремого ввімкнення (Technical Preview або через Copilot Labs). Якщо у вас є така
можливість – увімкніть, бо чат значно розширює корисність Copilot. - Створіть файл copilotinstructions.md у .github/ директорії вашого репозиторію (або через VS Code команда “Copilot:
Create Instruction File”). Це репозиторні інструкції, про які ми говорили у блоці про правила.
Заповніть його за рекомендаціями (огляд, стек, кодстайл, структура, скрипти) . Цей файл
буде автоматично врахований Copilot’ом під час генерації відповідей, особливо в чаті або при
використанні Copilot for PRs. Порада: Ви навіть можете попросити Copilot допомогти написати цей
файл! – розробники рекомендують такий мета-підхід як бонус . Наприклад, в Copilot Chat
скажіть: “Generate a copilot-instructions.md for this project including overview, tech stack, coding
guidelines, structure, and resources.” – він видасть чернетку, яку ви відредагуєте і затвердите. -
Опціонально, увімкніть файлові інструкції (.instructions files) – це ще експериментальна
можливість, коли можна мати окремі правила для конкретних типів файлів (наприклад, для
тестових файлів, або для фронтенд-коду). Вони зберігаються у спеціальній папці і застосовуються
Copilot Agent’ом залежно від імені файлу . Але ця деталь не обов’язкова до налаштування для
базової продуктивності.
Як ефективно використовувати Copilot: - Пишіть коментарі перед тим, як реалізовувати
функцію. Наприклад,
# Функція перевіряє надійність паролю:
# - Мінімум 8 символів
# - Містить цифри і спеціальні символи
def check_password_strength(password: str) -> bool:
#
Дайте Copilot’у можливість продовжити коментарі або одразу код функції. Він часто здатен на
основі опису згенерувати всю функцію одразу з дотриманням умов. - Якщо Copilot пропонує
занадто коротке чи просте рішення, а вам потрібно детальніше – розбийте проблему: спочатку
попросіть згенерувати структуру (напр. клас з методами), потім окремо – реалізацію для кожного
методу. Copilot краще справляється з локальними завданнями меншого розміру. -
Використовуйте Copilot Chat для нетривіальних запитань: "Поясни, що робить ось цей
фрагмент коду", "Як виправити помилку TypeError у такому-то місці", "Згенеруй тест кейси для
функції X". Chat може надавати розгорнуті відповіді, посилатися на рядки коду, які він бачив, і
навіть робити речі на кшталт аналізу цілого файлу. - Пам’ятайте, що Copilot – пропонує, а не
гарантує. Він може створити код, що виглядає правильно, але містить помилки. З часом ви
навчитеся вгадувати, де Copilot схильний помилятися (наприклад, з логікою індексів, або з
використанням змінних, яких немає в контексті). Обов’язково тестуйте згенерований код, як і
написаний вручну. - Не бійтеся відхиляти пропозиції. Якщо вам не подобається те, що підказує
Copilot, ви можете натиснути <kbd>Esc</kbd> і написати вирішення самі – можливо, AI навчиться з
вашого прикладу і наступного разу запропонує кращий варіант. Також можна викликати інші
варіанти (<kbd>Alt+[</kbd> і <kbd>Alt+]</kbd> за замовчуванням у VS Code перегортають
альтернативні снипети від Copilot). - Конфіденційність і ліцензії. Copilot іноді може пропонувати
фрагменти коду, знайдені в тренувальних даних. Хоча це рідко і здебільшого для дуже типової
задачі, але майте на увазі: якщо проект закритий, уникнете прийняття довгих шматків коду, які ви
самі не розумієте, щоб не втягнути випадково ліцензійно невідповідний код. Для корпоративних
користувачів Copilot є налаштування політик (телеметрія off, блокування певного витоку коду). В
89 30
90
91
11
Roo Code, до речі, всі ваші дані залишаються локально (відкритий код – можна перевірити, що він
не відправляє ваш код нікуди окрім як до моделі) .
Практична частина: приклади налаштування
Перейдемо до двох практичних сценаріїв, які демонструють, як налаштувати проект для роботи з
Roo Code та Copilot відповідно.
Приклад 1: Проект з Roo Code (AI dev team в дії)
Сценарій: Ви – розробник у невеликій команді, що створює веб-додаток на Python (Flask) з
фронтендом на React. Ви вирішили підключити Roo Code, щоб прискорити розробку і делегувати
частину рутинних завдань AI-агенту. Ось кроки, які ви виконуєте для налаштування:
Встановлення та підключення моделі. Через Marketplace VS Code встановлюєте
розширення Roo Code. Після перезапуску VS Code у лівій панелі з’являється іконка Roo. Ви
відкриваєте її і реєструєтеся в Roo (можна через GitHub OAuth). У налаштуваннях обираєте
провайдера моделі – припустимо, ви використовуєте OpenAI і маєте API-ключ, або для
економії почнете з безкоштовного OpenRouter. Вводите ключ і вибираєте модель
(наприклад, GPT-4 або Anthropic Claude 2 – Roo підтримує обидві). Увімкніть “Reasoning”
для моделі, щоб вона могла планувати багатокрокові рішення (ця опція доступна для
деяких моделей і дозволяє використовувати більше “думаючих” токенів) .
Налаштування режимів та авто-approve. За замовчуванням Roo Code дає 5 базових
режимів. Ви вирішуєте включити опцію автоматичного перемикання режимів – щоб агент
сам пропонував Architect→Code→Debug при потребі (Roo це робить за замовчанням, але
переконайтеся, що не вимкнено). Також заходите в налаштування Auto-Approve:
Дозволяєте редагування файлів без підтвердження (рішення: ви довіряєте дрібним
правкам, їх потім все одно бачите у діффах).
Забороняєте видалення файлів та виконання shell-команд без запиту дозволу (щоб
уникнути ризиків) .
Налаштовуєте, що створення нового файлу запитує дозвіл, а читання файлів – ні (читати
будь ласка, а от створювати – під контролем). Таким чином, ви не будете відволікатися на
кожну дрібницю, але й убезпечите проект від потенційно руйнівних дій агента.
Створення правил проекту. У корені репозиторію створюєте папку .roo/rules/ .
Усередині – кілька файлів:
01-overview.md – тут описуєте призначення застосунку (наприклад: “Це застосунок для
управління бібліотекою книг: бекенд на Flask, фронтенд на React. Користувачі можуть
реєструватися, додавати книги, брати їх в оренду. Цільова аудиторія – бібліотекарі та
читачі.”).
02-tech-stack.md – опис стеку: “Backend: Flask + SQLAlchemy, REST API. Frontend: React +
Redux, Material-UI. Auth – JSON Web Tokens. Тести – PyTest і Jest.”.
03-style-guide.md – ваші домовленості по коду: “Python: дотримання PEP8,
використовувати type hints. React: функціональні компоненти, hooks замість класів, всі
компоненти стилізувати через MUI theme. Коментарі англійською. Перевіряти вхідні дані
на бекенді (валидація через marshmallow).” Тут же можна додати: “Документуй ключові
функції docstring-ами. Логуй помилки серверу з рівнем WARN.” – і інші речі, які хочете щоб
AI завжди пам’ятав.
92
1.
93 94
2.
3.
4.
12
5.
6.
7.
8.
9.
12
04-conventions.md – наприклад, “У базі даних таблиці називати у однині, клас-моделі – в
однині з великої літери. У React-стані зберігати коди книжок як ISBN. Не використовувати
локальне сховище браузера для чутливих даних.” Це дрібні, але суттєві для вас
домовленості. Roo Code автоматично підтягне ці правила з папки при старті роботи
(порядок файлів за алфавітом/номером). Таким чином, кожен запит агент виконуватиме з
урахуванням цих правил.
Custom Instructions через інтерфейс. Альтернативно до п.3, ви могли відкрити у VS Code
вкладку Prompts в інтерфейсі Roo Code і заповнити розділ “Custom Instructions for
Workspace”. Це зручніше для швидкого редагування, але зберігає все в один файл
.roorules . Оскільки наша команда хоче зберігати правила в репозиторії, ми обрали
структуру з файлів. До речі, Roo Code дозволяє імпортувати/експортувати ці
налаштування – їх можна переносити між проектами легко .
Додавання навичок. Припустимо, у нашому проекті є специфічна задача: конвертувати
завантажені зображення обкладинок книг у ескізи (thumbnails). Це нетривіально, треба
використовувати, скажімо, бібліотеку Pillow, додержуватися розмірів, зберігати файли на
S3. Щоб AI добре з цим справлявся, створюємо навичку:
Папка .roo/skills/thumb-generator/ і файл SKILL.md в ній.
Описуємо:
name: thumb-generator
description: Create thumbnails (JPEG, 200x300) from uploaded book cover
images using Pillow.
---
Далі в Markdown: кроки (1. Перевірити, чи встановлено Pillow. 2. Завантажити зображення,
3. Відмасштабувати до 200x300 без зміни співвідношення сторін, 4. Зберегти JPEG з якістю
80%, 5. Викласти на AWS S3 через boto3), шаблон коду (можна навіть навести приклад
функції, яку хотіли б), поширені проблеми (немає бібліотеки – порадити pip install
Pillow , помилки S3 – перевірити креденшали, тощо).
Тепер, коли ми попросимо щось типу: “Додай функціонал створення ескізів для обкладинок
книг після завантаження”, Roo Code розпізнає по словам thumbnails/images/Pillow наш skill і
підключить ці інструкції. Агент запропонує код, який виконує всі кроки, використовуючи
Pillow, як ми й хотіли.
Цю навичку також додаємо в git. Якщо в майбутньому вона знадобиться на іншому проекті
– можна перемістити до ~/.roo/skills/ для глобального використання.
Slash-команди для рутини. Наша команда вирішила створити кілька команд:
/db-migrate – щоб Roo Code сам відкрив термінал і виконав alembic upgrade head
(накочування міграцій) та alembic revision --autogenerate -m "..." при потребі.
Команда містить frontmatter mode: command (щоб agent міг виконувати shell), і текст на
кшталт “Run database migrations using Alembic”.
/gen-api-docs – агент збирає всі ендпоінти Flask і формує Markdown з переліком API (міг
би навіть згенерувати OpenAPI spec). Це складніша команда: можливо, вона спочатку
інструктує прочитати файли routes/ і controllers/ , потім скласти документ. Такі
багатокрокові речі – нормальний кейс для slash-команд.
/review-sec – наша перевірка безпеки. Вона переключає агент у режим Ask (щоб нічого
не змінював) і дає інструкцію проглянути код на типові уразливості (SQL injection, XSS,
hardcoded secrets). Цю команду будемо запускати перед релізом на критичних модулях.
Команди зберігаємо у .roo/commands/ і теж додаємо в репозиторій. Тепер всі
розробники мають однакові ярлики для цих дій.
Використання агентів у роботі. Тепер, коли все налаштовано, кожен може працювати так:
10.
11.
95 96
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.
13
Починаючи нову задачу, писати у Roo Code чат: “Режим Architect: сплануй додавання функції
резервування книги на 7 днів, з урахуванням що одночасно книгу може зарезервувати лише
одна особа.”. Агент (Architect Mode) видасть план: “1. Додати поле reserved_by в модель
Book... 2. Метод reserveBook у BookService... 3. API endpoint POST /book/<id>/reserve... 4. При
підтвердженні – відправити email...” і т.д. .
Переключитися в Code Mode і виконувати кроки: спершу попросити “Додай поле reserved_by
до моделі Book (SQLAlchemy), та міграцію”. Агент внесе зміни в файл моделі і створить новий
файл міграції (спитає назву – ви підтверджуєте). Потім “Реалізуй метод reserve_book у
контроллері, врахуй перевірку, що reserved_by порожній”. Потім “Створи тест, що
резервування двічі не дозволяється” – агент напише тест.
Зіштовхнувшись з багом (скажімо, резервація не працює як очікується), перейти в Debug
Mode: “Знайди причину, чому резервування книги не встановлює reserved_by”. Агент
проаналізує (можливо, знайде, що забули виклик save, або помилка у логіці), потім або сам
виправить, або запропонує виправлення. Ви схвалюєте – він редагує код і повторно
запускає тести.
Для документування API: можна виконати /gen-api-docs – AI збере ендпоінти і
оформить Markdown документ.
Перед злиттям гілки – /review-sec на змінених файлах, щоб отримати додаткову
впевненість.
Коли потрібно виконати міграції на локальній БД: /db-migrate – і Roo зробить це,
відобразивши результат у чаті (з вашою згодою на виконання команди).
Протягом усього цього, правила та навички непомітно діють: AI завжди пише код в
нашому стилі (PEP8, типи), завжди пам’ятає про JWT-автентифікацію (бо ми згадали це в
overview), і коли генерує код з зображеннями – слідує нашим інструкціям з Pillow-навички.
Як результат, згенерований код мінімально потребує доопрацювання – він уже
відповідає багатьом вимогам проекту.
Цей приклад демонструє, як комплексне налаштування Agentic IDE допомагає розробникам
виконувати завдання швидше і впевненіше. Багато рутинних речей (особливо пов’язаних з
шаблонним кодом або повторюваними перевірками) агент бере на себе. Водночас, завдяки
правилам і контролю, команда довіряє агенту, бо він діє “на їхніх умовах” , в межах визначених
стандартів.
Приклад 2: Проект з GitHub Copilot у VS Code
Сценарій: Інший проект – невеликий веб-сервіс на JavaScript/TypeScript (Node.js) з фронтендом
на HTML/CSS (без фреймворку). Команда використовує GitHub Copilot для прискорення розробки.
Розглянемо, як вони адаптують Copilot під свій проект і робочий процес:
Інтеграція Copilot. Розробники встановили GitHub Copilot розширення у VS Code і увійшли
в систему. Copilot вже почав пропонувати доповнення коду. Щоб розширити можливості,
команда ввімкнула Copilot Chat (у налаштуваннях VS Code Insider функція "GitHub Copilot
Chat: Enable").
Файл інструкцій для репозиторію. В корені проекту (назвемо його BookingApp) створено
.github/copilot-instructions.md з наступним вмістом:
# BookingApp – Project Overview
BookingApp is a simple web service for booking appointments with
specialists. It includes a Node.js backend (Express) and a minimal HTML/
JS frontend. Users can view available slots and book one.
22.
97 36
23.
24.
25.
26.
27.
28.
98
1.
2.
14
## Tech Stack in use
**Backend:** Node.js with Express. Data stored in MongoDB (Mongoose
ODM). Uses JWT for authentication.
**Frontend:** Plain HTML, CSS (Bootstrap), Vanilla JS for interactions
(no SPA framework).
**Testing:** Jest for backend unit tests; no dedicated frontend
framework (just manual testing).
## Project and Code Guidelines
- Use modern ES6+ syntax (arrow functions, async/await).
- All code must be in TypeScript (.ts) and transpiled; use JSDoc for
public functions.
- Follow ESLint rules (Airbnb style). 2 spaces indentation.
- Commit messages should be in present tense and concise.
- Security: avoid using `eval` or any unsafe user input handling.
## Project Structure
- `/src` – server code (Express routes, models, controllers).
- `/public` – static frontend files (served by Express).
- `/src/models` – Mongoose models (e.g., User.ts, Booking.ts).
- `/src/routes` – Express route definitions.
- `/src/controllers` – logic for each route separate from routes.
- `/src/utils` – helper functions (e.g., date formatting).
- `/tests` – Jest test files parallel to src structure.
## Resources
- A `setup.sh` script sets environment variables and starts MongoDB for
local dev.
- Use `npm run dev` to start the server with Nodemon.
- Postman collection is available for API testing (see docs/
Postman.json).
Цей файл охоплює всі важливі моменти: і функціонал, і стек, і стиль коду, і структуру папок –
фактично, міні-документація для Copilot . Завдяки цьому Copilot буде краще
розуміти, що ми очікуємо. Наприклад, коли попросимо згенерувати контролер для
бронювання, Copilot вже буде знати, що ми працюємо з Express + Mongo, де лежать моделі,
і побудує код відповідно.
Використання Copilot при написанні коду.
Створення нового модуля: Припустимо, потрібно реалізувати новий route – скасування
бронювання. Розробник створює файл cancelBooking.ts в src/controllers/ . Він
пише сигнатуру функції:
import { Request, Response } from 'express';
import Booking from '../models/Booking';
export async function cancelBooking(req: Request, res: Response) {
//
}
Та додає коментар над функцією:
89 22
3.
4.
15
/**
 * Cancels a booking by its ID if it belongs to the authenticated user.
 * - Verifies JWT and user identity (done in middleware).
 * - Checks if booking exists and is not already canceled.
 * - Marks the booking as canceled and frees the slot.
 * - Returns success message or error.
 */
Після цього натискає Enter в тілі функції – Copilot пропонує реалізацію, наприклад:
try {
const bookingId = req.params.id;
const booking = await Booking.findById(bookingId);
if (!booking) {
return res.status(404).json({ error: 'Booking not found' });
}
if (booking.status === 'canceled') {
return res.status(400).json({ error: 'Booking already
canceled' });
}
// Assuming booking.user equals authenticated user id (middleware
ensures it)
booking.status = 'canceled';
await booking.save();
return res.json({ message: 'Booking canceled successfully' });
} catch (error) {
console.error('Cancel booking error:', error);
return res.status(500).json({ error: 'Internal server error' });
}
Цей код Copilot згенерував, враховуючи опис у коментарі. Розробник перевіряє: код
відповідає стилю (async/await, try/catch, JSON відповіді), враховані основні випадки.
Можливо, він додає перевірку, що booking.userId === req.user.id для безпеки –
Copilot міг не знати імені поля, тож треба підправити. Але 90% роботи зроблено буквально
за секунди.
Генерація тестів: Тепер хочемо тест на цей контролер. Створюємо файл
cancelBooking.test.ts у папці tests/controllers/ . Пишемо опис:
import request from 'supertest';
import app from '../../src/app'; // Express app
import Booking from '../../src/models/Booking';
describe('DELETE /api/bookings/:id', () => {
it('should cancel the booking and return success for valid request',
async () => {
//
});
});
5.
16
Далі натискаємо <kbd>Ctrl+Enter</kbd> в VS Code, щоб відкрити Copilot Chat і вводимо:
"Write the test implementation for the above, including creating a booking, making a DELETE request,
and checking the response and database.". Copilot Chat проаналізує відкритий код тесту і,
використовуючи контекст (воно побачить Booking модель, можливо, і app), згенерує
повноцінний тест: створить фейковий Booking (може, через Factory або прямо Mongoose),
виконає request(app).delete('/api/bookings/123') , перевірить, що статус 200, і що
в БД booking має status 'canceled'. Нам залишиться скоригувати дрібниці (наприклад,
вставити правильний ID, чи мокнути JWT-мідлвару якщо треба).
Вирішення помилки: Припустимо, тест не проходить – отримуємо 500 помилку. В логах
бачимо помилку "TypeError: Cannot read property 'id' of undefined". Не одразу зрозуміло, де.
Відкриваємо Copilot Chat і питаємо: "I have a TypeError cannot read property 'id'. What could be
causing this in my cancelBooking code?". Copilot, маючи контекст cancelBooking.ts ,
здогадується, що мабуть req.user undefined (наприклад, ми припустили, що middleware
встановлює req.user , а в тесті цього не було). Він відповідає: "Ймовірно, req.user не
визначений, тому req.user.id дає помилку. Переконайтеся, що аутентифікація
виконана або змініть код перевірки." – і може навіть запропонувати додати цю перевірку
або використовувати req.auth з JWT. Це направляє розробника до рішення. Він
виправляє код (додає умовне якщо нема req.user – вертати 401, або коректно мокує у
тесті користувача).
Оптимізація коду: Copilot також можна спитати: "Refactor the cancelBooking function to reduce
database calls.". Він, можливо, запропонує зробити пошук і оновлення в одному запиті
(findByIdAndUpdate), що швидше. Таким чином, AI допомагає не тільки писати код, а й
покращувати його.
Спільні налаштування Copilot для команди. Коли проект налаштований, інші
розробники отримують ці ж benefits. Файл інструкцій у репозиторії – спільний, всі з ним
працюють і доповнюють при потребі (якщо, наприклад, вирішили додати Angular для
адмін-панелі, то допишуть у “Frontend” секцію про Angular, щоб Copilot теж знав про це).
Також тим, хто використовує Copilot Chat, можна розіслати Prompt Files – наприклад, шаблон
запиту "Generate CRUD endpoints for model X", який включає підказку перерахувати методи
GET/POST/PUT/DELETE. Це трохи схоже на slash-команди Roo, тільки у Copilot це реалізовано
інакше – через окремі файли або розширення Copilot Labs.
Щоденна робота з Copilot. Розробники пишуть код значно швидше, тому що:
Copilot завершує за них типову низькорівневу писанину (пробігаючи циклом, обробку
помилок, ініціалізацію об’єктів).
Якщо потрібно новий пакет – достатньо написати npm install axios у терміналі, а
потім написати коментар // використати axios для HTTP запиту до External API ,
Copilot сам запропонує приклад використання, не треба лізти у документацію.
В разі сумнівів – Copilot Chat доступний: запитати, чим відрізняється метод, пояснити
помилку, перевірити, чи немає уразливостей у шматку коду (до речі, Copilot може
відповісти: "у вашій функції пароля не хешується перед збереженням, це небезпечно" –
тобто виступити як code reviewer).
За годину-дві роботи Copilot може згенерувати десятки рядків коду, зберігаючи стиль. Це
помітно прискорює прогрес проекту. Один з розробників пожартував, що Copilot – “це як
стажер, що завжди поруч: треба – підкаже, нудну роботу зробить, але відповідальність все
одно на нас”. І це досить точно: Copilot не пише ідеальний код, але дає чернетку, яку
людина вже швидко полірує.
Підсумок цього прикладу: GitHub Copilot вимагає менше налаштувань, проте файл інструкцій і
чіткі звички в написанні промптів/коментарів піднімають його ефективність на новий рівень. За
допомогою Copilot команда отримує вигоду майже відразу – з першого дня він починає
доповнювати код. А з часом, навчившись правильно формулювати запити, розробники можуть
6.
7.
8.
9.
10.
11.
12.
13.
17
вирішувати складніші проблеми через Copilot Chat. Вони не турбуються про “дозволи” чи режими,
але знають, що AI може помилятися, тож уважно код рев’юять результати. Copilot стає для них
інструментом прискорення (velocity), тоді як дизайн рішень і критичні моменти вони тримають
під своїм контролем.
Рекомендації та найкращі практики
На завершення – узагальнимо ключові поради, які допоможуть зробити вашу роботу з
генеративним ШІ найбільш продуктивною та безпроблемною:
1. Визначте правила і контекст з самого початку. Не починайте використовувати AI
наосліп – витратьте час на створення файлу інструкцій (Copilot) або .roo/rules/ (Roo
Code). Чітко задокументуйте ваш проект, стиль і очікування для AI . Це основа для
релевантних відповідей. AI-асистент, отримавши “institutional knowledge” про проект,
діятиме майже як досвідчаний член команди .
2. Налаштуйте середовище один раз – вигравайте постійно. Інтеграція API-ключів,
доступ до модельок, індексація коду, розбиття на режими, auto-approve – всі ці
налаштування можуть здатися морокою, але вони дуже важливі. Правильно
сконфігурований Agentic IDE дозволить вам зосередитися на творчих аспектах, делегуючи
рутину агентам. Один раз налаштували – і кожен новий таск вирішується швидше, ніж без
цього.
3. Використовуйте сильні сторони інструментів. Copilot блискавично пропонує
доповнення коду – давайте йому підказки через коментарі і назви функцій, щоб він
генерував саме те, що треба. Roo Code може автономно планувати та виконувати серії дій –
довіряйте йому рутину, але контролюйте критичне. Якщо Roo Code пропонує переключити
режим або виконати команду – завжди осмислюйте і підтверджуйте, розуміючи, що
відбувається.
4. Постійно вчіться правильно промптити. Промпт-інжиніринг – новий скіл розробника.
Пробуйте різні формулювання, порівнюйте результати. Діліться в команді вдалими
прийомами: можливо, хтось знайшов, що запит "Explain X" дає кращу відповідь, ніж "What
is X?". Обмінюйтеся knowledge, як обмінюєтеся рецептами коду.
5. Інтегруйте AI у workflow, але не покладайтеся на 100%. Нехай AI пише чернетки,
генерує тести, шукає баги. Але обов’язковою стадією повинен бути людський перегляд:
рев’ю коду, прогін тестів, аналіз безпеки. Це особливо важливо для автономних агентів: як
ми бачили з огляду Roo Code, іноді агент може зайти в тупик або зробити зайве, і тут
необхідне втручання розробника . Ваша експертиза – остання інстанція.
6. Підтримуйте налаштування в актуальному стані. Проект еволюціонує – додаються
нові бібліотеки, змінюються вимоги. Вносьте ці зміни і до AI-інструкцій (правил, skills,
prompt-файлів). Так само, якщо помітите, що AI систематично помиляється в якомусь
аспекті, можливо варто додати нове правило чи приклад показати. Наприклад, модель
постійно забуває про обмеження – додайте явне речення в правила, і помилка зникне.
Гнучкість і вдосконалення – запорука ефективності AI-помічника в довгостроковій
перспективі .
7. Дбайте про спільну базу знань. Як і код, AI-конфігурації мають бути доступні команді:
включайте їх у репозиторій (окрім, звісно, секретних ключів). Документуйте в README, що у
нас є такий-то skill, такі-то команди. Заохочуйте колег пропонувати нові навички чи
правила, якщо бачать, що AI міг би краще допомагати. Це робить використання AI
командним, а не індивідуальним — як ніби у вас реально з’являється новий співробітник, з
яким всі взаємодіють.
8. Пам’ятайте про етичні та легальні межі. Не забувайте, що AI може згенерувати код,
який порушує чиюсь ліцензію (хоч шанс малий, але був прецедент). Також стежте, щоб у
•
99 30
100
•
•
•
•
101 102
•
31
•
•
18
правилах не передавати в сторонні API чутливий код (якщо це заборонено політикою
компанії). Обирайте моделі з підтримкою конфіденційності, якщо працюєте над закритим
проектом. В Roo Code можна, наприклад, підняти локальну LLM (але вона буде слабша). В
Copilot for Business є toggle “do not retain code snippets”. Загалом, використовуйте AI
відповідально.
9. Не бійтесь експериментувати і отримувати задоволення. Робота з AI – це нове поле,
де багато що залежить від креативності. Пробуйте нові фічі (наприклад, Roo Code
Marketplace зі спільними модами, або Copilot з режимом голосового вводу). Іноді
найнесподіваніші ідеї промптів дають класний результат. А головне – отримуйте
задоволення від прискорення і полегшення роботи. Менше нудного коду – більше фокусу
на вирішенні цікавих задач. Саме такої мети ми і прагнемо, впроваджуючи Agentic IDE.
На цьому завершуємо. Ми розглянули, як правила, команди та навички роблять взаємодію з
AI-агентами в IDE більш керованою та ефективною. Інструменти на кшталт Roo Code та GitHub
Copilot вже сьогодні здатні суттєво підвищити продуктивність розробників, якщо правильно їх
налаштувати і використовувати. Сподіваюсь, тепер у вас є розуміння, з чого почати і як діяти, щоб
перетворити AI з просто цікавої іграшки на справді корисного члена вашої dev-команди. Успіхів
в роботі і хай ваш новий AI-напарник приносить тільки позитивний досвід!
