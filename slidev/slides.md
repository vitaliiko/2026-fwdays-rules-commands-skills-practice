---
theme: default
title: Правила, команди та навички для Agentic IDE
presenter: true
drawings:
  persist: false
---

<div style="display: flex; align-items: center; justify-content: space-between; gap: 2rem;">
  <div style="flex: 1;">
    <h1 style="font-size: 3rem; font-weight: bold; margin-bottom: 1rem;">Правила, команди та навички для Agentic IDE</h1>
    Масштабування розробки з AI-агентами в VS Code
  </div>
  <img src="/generated/dev-and-kangaroo-tasks.png" alt="Розробник і кенгуру борються з багатьма завданнями" style="width: 400px; max-width: 45vw; height: auto; object-fit: contain;" />
</div>

<!--
Це вступна слайд презентації про те, як налаштувати IDE для ефективної роботи з AI-помічниками. Мета - навчити розробників використовувати правила, команди та навички для максимізації продуктивності.
-->

---

## Чому Agentic IDE важливий?

<v-clicks>

- Генеративний ШІ змінює способи розробки коду
- AI-агенти можуть виконувати багатоетапні завдання автономно
- Потреба в контролі та стандартизації роботи AI
- Продуктивність + безпека = керований розвиток

</v-clicks>

<!--
Розробники вже мають доступ до потужних AI-інструментів, але часто використовують їх невдало. Без правильного налаштування AI генерує код, який не відповідає стандартам команди, порушує безпеку, або просто не робить те, що треба. Agentic IDE вирішує це через систему правил, режимів, команд і навичок.
-->

---

## Що розглядатимемо

<v-clicks>

1. **Рoo Code** та **GitHub Copilot** - два основні інструменти
2. **Правила (Rules)** - як задати AI контекст проекту
3. **Режими (Modes)** - спеціалізовані ролі для агента
4. **Промпти** - мистецтво спілкування з AI
5. **Навички (Skills)** - спеціалізовані знання для завдань
6. **Команди (Commands)** - макроси для частих операцій
7. **Практичні приклади** - налаштування реальних проектів

</v-clicks>

<!--
Презентація базується на документації Roo Code та GitHub Copilot, а також на best practices спільноти. Ми покриємо як теорію, так і практику - із реальними прикладами конфігурацій.
-->

---

## Встановлення AI-помічника

<v-clicks>

- **Roo Code** - відкритий AI-асистент, модель-незалежний
- **GitHub Copilot** - пропрієтарний, на базі OpenAI
- Обидва інтегровані в VS Code як розширення
- Roo Code більш автономний, Copilot - простіший

</v-clicks>

<!--
Roo Code підтримує десятки моделей (OpenAI, Anthropic, Google, lokальні), що робить його гнучким. Copilot працює "із коробки" після входу в GitHub. Для цієї презентації ми розглянемо обидва, щоб розробники могли обрати те, що краще для них.
-->

---

## Аутентифікація та доступ

<v-clicks>

- **Roo Code**: підключити API-провайдера (OpenAI, OpenRouter, локально)
- **Copilot**: вхід через GitHub, підписка (Individuals або Business)
- Індексація коду для семантичного пошуку
- Контроль дій AI через auto-approve налаштування

</v-clicks>

<!--
Roo Code дозволяє обрати провайдера і модель - це дає гнучкість та контроль над витратами. Copilot "просто працює", але вимагає GitHub-акаунта. Обидва можуть індексувати код для кращого розуміння контексту.
-->

---

## Правила (Rules) - основа контексту

<v-clicks>

- **Глобальні правила**: `~/.roo/rules/` - для всіх проектів
- **Проектні правила**: `.roo/rules/` в репозиторії - специфічні для проекту
- **Режим-специфічні**: `.roo/rules-<mode>/` - для конкретного режиму
- Правила - це Custom Instructions для моделі

</v-clicks>

<!--
Правила - це по суті системні промпти, які завжди присутні в контексті моделі. Вони задають стиль кодування, стандарти, обмеження. Без них AI не "читає ваші думки" - модель не знає, що ви очікуєте. Правила вирішують це проблему.
-->

---

## Що писати в правилах

<v-clicks>

- **Огляд проекту**: мета, цільова аудиторія, функції
- **Технічний стек**: мови, фреймворки, БД, інфраструктура
- **Кодстайл**: форматування, конвенції, типізація
- **Структура проекту**: організація папок, відповідальність
- **Ресурси**: скрипти, команди для запуску, тестування, деплою

</v-clicks>

<!--
Хороші правила - це "інstitutional knowledge" про проект. Вони економлять час моделі на розуміння, де що лежить, і як ви хочете щось робити. Це робить AI більш ефективним "членом команди".
-->

---

## GitHub Copilot Instructions

Для **GitHub Copilot** створіть `.github/copilot-instructions.md`:

<v-clicks>

- Файл інструкцій у корені репозиторію
- Copilot читає його при кожному запиті
- Аналогічна структура до Roo Code правил
- Можна просити Copilot допомогти написати цей файл

</v-clicks>

<!--
GitHub недавно запровадив цей механізм, наслідуючи Roo Code. Copilot "краще працює, коли має правильний контекст" - це по суті кажучи Copilot'у про вашу команду та проект, як його новому члену.
-->

---

## Режими (Modes) - спеціалізовані ролі

<v-clicks>

- **Architect** - планування, дизайн, тільки читання файлів
- **Code** - написання коду, редагування, рефакторинг
- **Debug** - відлагодження, аналіз помилок, логування
- **Ask** - питання-відповіді, не змінює код
- **Test** - написання та оптимізація тестів

</v-clicks>

<!--
Режими - це унікальна особливість Roo Code. Кожен режим обмежує можливості агента та його фокус. Це робить роботу більш безпечною та точною. Без режимів агент може "кинутися писати код" без розуміння контексту, що призводить до помилок.
-->

---

## Додаткові режими Roo Code

<v-clicks>

- **Orchestrator** - координація інших режимів для багатокрокових завдань
- **Custom Modes** - користувацькі режими з власними інструкціями
- Режими можуть бути глобальними або специфічними для проекту
- Маркетплейс шаблонів режимів від спільноти

</v-clicks>

<!--
Orchestrator Mode дозволяє агенту розбивати велику задачу на підзадачі та координувати різні ролі. Custom Modes дозволяють створити спеціалізовані режими, наприклад для SQL Assistant або UX Writer.
-->

---

## GitHub Copilot - неявні режими

GitHub Copilot не має явних режимів, але має різні контексти:

<v-clicks>

- **Copilot Inline** - автодоповнення коду у реальному часі
- **Copilot Chat** - окремий чат для питань і команд
- **Copilot for PRs** - рецензування pull request'ів
- **Copilot CLI** - конвертація природної мови в shell-команди

</v-clicks>

<!--
У Copilot можна імітувати режимність через явні промпти. Наприклад, спочатку попросити план (як у Architect Mode), потім реалізацію (як у Code Mode). Це дає більш структурований результат.
-->

---

## Промпти - мистецтво спілкування з AI

<v-clicks>

- **Чітка формулювання**: модель не здогадується про ваші наміри
- **Розбиття завдання**: великі фічі розбивайте на підзадачі
- **Контекстні підказки**: використовуйте файли, символи, коментарі
- **Формат відповіді**: уточніть, що саме хочете (код, план, пояснення)

</v-clicks>

<!--
Промпт-інжиніринг - новий скіл розробника. Поганий промпт: "Напиши програму для роботи з БД". Гарний: "Напиши функцію на Python, яка підключається до PostgreSQL, робить SELECT запит до таблиці users, повертає результат у JSON, з обробкою помилок з'єднання, використовуючи psycopg2".
-->

---

## Техніки написання промптів

<v-clicks>

- **Розбиття завдання**: спочатку план, потім реалізація по кроках
- **Посилання на контекст**: @назва_функції, @файл - підказати моделі
- **Повторне формулювання**: якщо AI не розумів, спробуйте інший порядок слів
- **Обережність з відкритими завданнями**: кожен промпт має конкретну мету

</v-clicks>

<!--
У Roo Code можна посилатися на файли та символи явно, щоб модель їх прочитала. У Copilot контекст визначається автоматично з відкритих файлів. Експериментуйте з перефразуванням - LLM іноді краще реагають на інший порядок слів.
-->

---

## Промпти для Roo Code

<v-clicks>

- Використовуйте режими у промпті: "Режим Architect: сплануй..."
- Агент видасть план - потім у Code Mode реалізуйте по кроках
- Посилайтесь на попередній план для послідовності дій
- Roo Code підтримує інструменти (tools) - read_file, write_file, new_task

</v-clicks>

<!--
Режими як частина інструкції дозволяють агенту знати, яку роль грати. "Режим Architect: як додати функціонал реєстрації?" видасть план. Потім "Режим Code: реалізуй крок 1..." зміниться код. Така послідовність більш ефективна.
-->

---

## Навички (Skills) - спеціалізовані знання

<v-clicks>

- **Навичка** - пакет інструкцій для конкретного завдання
- Діють "за вимогою" - завантажуються при релевантному запиті
- Вирішують проблему "засмічення" базового контексту
- Можуть містити код, шаблони, ресурси, не тільки інструкції

</v-clicks>

<!--
Навички - це розумна сегментація знань. Замість тримати інструкції про обробку PDF весь час в контексті, вони завантажуються лише коли ви дійсно працюєте з PDF. Це економить токени і робить модель менше розгубленою.
-->

---

## Структура навички

```
.roo/skills/pdf-processing/
├── SKILL.md (метаданих + інструкції)
├── template.py (готовий код)
└── examples/ (приклади)
```

<v-clicks>

- **Назва навички**: унікальна, дескриптивна
- **Description**: як Roo Code визначає, коли активувати
- **Інструкції**: кроки, best practices, шаблони
- **Ресурси**: код, дані, шаблони для агента

</v-clicks>

<!--
Навичка активується за описом (description). Якщо ви спитаєте "Витягни таблиці з PDF", Roo Code розпізнає по словам "таблиці" та "PDF" і підвантажить навичку pdf-processing. Description має бути конкретною, не загальною.
-->

---

## Best practices для навичок

<v-clicks>

- Формулюйте description так, щоб однозначно відповідала наміру
- Уникайте конфліктів з основними правилами
- Версіонуйте навички у репозиторії
- Перевикористовуйте глобальні навички (`~/.roo/skills/`)
- Тестуйте та оновлюйте з часом

</v-clicks>

<!--
Загальна навичка "web development help" може помилково спрацьовувати. Краще кілька вузьких: "React hooks best practices", "Django ORM migrations". Глобальні навички поділяються з усіма проектами, тому варто інвестувати у якісні.
-->

---

## Slash-команди (макроси для AI)

<v-clicks>

- Короткі текстові тригери для частих операцій
- Файл команди → назва команди (review.md → /review)
- Зберігаються в `~/.roo/commands/` або `.roo/commands/`
- Можуть мати frontmatter з метаданими

</v-clicks>

<!--
Slash-команди економлять час на повторювані завдання. Замість щоразу писати довгу перевірку коду, ви набираєте /review. Це макрос для AI, який підставляє заздалегідь підготовлений промпт.
-->

---

## Структура команди

```markdown
---
description: Comprehensive code review
argument-hint: <file or directory>
mode: debug
---

Please review this code for:
- Performance issues
- Security vulnerabilities
- Code style violations
- Potential bugs
```

<!--
Команда може мати description (для меню), argument-hint (яких параметрів очікувати) і mode (в який режим перейти). При виборі команди вона вставиться в поле вводу, і курсор чекатиме аргументу. Це дуже зручно для стандартизації роботи команди.
-->

---

## Приклади корисних команд

<v-clicks>

- `/db-migrate` - виконати міграції БД
- `/gen-api-docs` - згенерувати документацію API
- `/review-sec` - перевірка безпеки коду
- `/docstring` - генерування DocString для функції
- `/translate <lang>` - переклад тексту

</v-clicks>

<!--
Все залежить від вашого проекту. Команди можна зберегти в репозиторії і поділитися з командою - всі отримають однакові ярлики. Це зменшує імовірність людської помилки і економить час.
-->

---

## GitHub Copilot - команди та промпти

<v-clicks>

- Copilot не підтримує slash-команди як такі
- Замість цього є **Prompt Files** - схоже на команди
- Можна зберегти довгі промпти і викликати їх швидко у чаті
- Спільні для команди через розширення Copilot Labs

</v-clicks>

<!--
У Copilot механізм трохи інший, але мета та сама - стандартизувати та прискорити частих операції. Невдовзі Copilot, можливо, забезпечить більш тісну інтеграцію (Custom Agents).
-->

---

## Можливості GitHub Copilot

<v-clicks>

- **Inline доповнення** - у реальному часі при написанні коду
- **Copilot Chat** - окремий чат для запитань і команд
- **PR Reviews** - рецензування pull request'ів
- **Copilot CLI** - конвертація природної мови в shell-команди

</v-clicks>

<!--
Copilot - це набір інструментів, не один. Inline доповнення основне - прискорює написання типового коду. Chat розширює можливості для складніших запитань. PR Reviews дуже корисна для навчання менш досвідчених розробників.
-->

---

## Наскільки Copilot "agentic"?

<v-clicks>

- На відміну від Roo Code, Copilot не виконує довільних дій автономно
- Він пропонує, ви затверджуєте
- Менш ризику "щось піде не так" без вашого відома
- Але функціонально обмежений - не може масово редагувати файли

</v-clicks>

<!--
Copilot простіший і безпечніший для початківців. Якщо скажете "створи мені новий модуль з такими-то файлами", Copilot не зможе створювати файли сам - вам доведеться робити це поетапно. Це перевага для безпеки, але недолік для швидкості.
-->

---

## Налаштування Copilot для проекту

<v-clicks>

1. Встановіть розширення GitHub Copilot у VS Code
2. Виконайте логін в GitHub
3. Увімкніть Copilot Chat (за потреби)
4. Створіть `.github/copilot-instructions.md`
5. Заповніть файл інструкцій (огляд, стек, кодстайл, структура)

</v-clicks>

<!--
Основне - це файл інструкцій. Він охоплює всі важливі моменти: функціонал, стек, стиль коду, структуру папок. Copilot буде краще розуміти, що ви очікуєте, і генерувати релевантніший код.
-->

---

## Ефективне використання Copilot

<v-clicks>

- Пишіть коментарі перед реалізацією функції
- Розбивайте складні завдання на менші
- Використовуйте Copilot Chat для нетривіальних запитань
- Пам'ятайте - Copilot пропонує, не гарантує
- Обов'язково тестуйте згенерований код

</v-clicks>

<!--
Коментарій, описуючи функцію, дозволяє Copilot згенерувати більш релевантний код. Copilot краще справляється з локальними завданнями меншого розміру. На складні питання Chat дає розгорнуті відповіді та може посилатися на рядки коду.
-->

---

## Приклад: Рoo Code налаштування

Проект: Flask + React веб-додаток

<v-clicks>

1. Встановлення та підключення моделі
2. Налаштування режимів та auto-approve
3. Створення правил проекту (.roo/rules/)
4. Додавання навичок (.roo/skills/)
5. Création slash-команд (.roo/commands/)

</v-clicks>

<!--
Це реальний приклад налаштування Roo Code для проекту. Ми розглянемо кожен крок детально на наступних слайдах.
-->

---

## Правила проекту Flask + React

```
.roo/rules/
├── 01-overview.md
├── 02-tech-stack.md
├── 03-style-guide.md
└── 04-conventions.md
```

<v-clicks>

- **overview.md**: мета app, користувачі, функції
- **tech-stack.md**: Backend Flask, Frontend React, Auth JWT
- **style-guide.md**: PEP8, type hints, React hooks, Material-UI
- **conventions.md**: таблиці в однині, ISBN коди, безпека

</v-clicks>

<!--
Правила розташовуються в алфавітному порядку і завантажуються автоматично. Кожен запит агент виконуватиме з урахуванням цих правил. Вони економлять час на поясненнях - AI одразу знає стиль і вимоги.
-->

---

## Навичка для обробки зображень

```
.roo/skills/thumb-generator/SKILL.md
```

<v-clicks>

- **name**: thumb-generator
- **description**: Create thumbnails (JPEG, 200x300) from book covers using Pillow
- Кроки: перевірка Pillow, завантаження, масштабування, збереження JPEG, вивантаження на S3
- Шаблон коду та поради щодо типових проблем

</v-clicks>

<!--
Коли ви попросите "Додай функціонал створення ескізів для обкладинок", Roo Code розпізнає ключові слова і підвантажить цю навичку. Агент запропонує код, який слідує усім кроках, використовуючи Pillow, як вказано.
-->

---

## Команди для Flask проекту

<v-clicks>

- `/db-migrate` - виконати alembic upgrade head
- `/gen-api-docs` - збір ендпоінтів Flask і Markdown документація
- `/review-sec` - перевірка безпеки (SQL injection, XSS, hardcoded secrets)

</v-clicks>

<!--
Команди зберігаються у `.roo/commands/` і додаються в репозиторій. Всі розробники мають однакові ярлики. Перед релізом команда запускає `/review-sec` на критичних модулях для додаткової впевненості.
-->

---

## Робота з Roo Code - послідовність

<v-clicks>

1. Architect Mode: "Сплануй додавання функції резервування книги"
2. Code Mode: "Додай поле reserved_by до моделі Book (SQLAlchemy)"
3. Code Mode: "Реалізуй метод reserve_book у контроллері"
4. Debug Mode: "Знайди причину, чому резервування не працює"
5. Команда: `/gen-api-docs` для документації

</v-clicks>

<!--
Це демонструє повний цикл: планування → реалізація → тестування → документування. Кожен крок - це окремий запит у відповідному режимі. Така послідовність більш ефективна, ніж одна гігантська команда.
-->

---

## Приклад: GitHub Copilot налаштування

Проект: Node.js + Express + MongoDB (BookingApp)

<v-clicks>

1. Встановлення GitHub Copilot розширення
2. Вхід через GitHub і ввімкнення Copilot Chat
3. Створення `.github/copilot-instructions.md`
4. Заповнення файлу інструкцій

</v-clicks>

<!--
Copilot вимагає менше налаштувань, ніж Roo Code. Основне - це файл інструкцій. Потім Copilot почне пропонувати доповнення, враховуючи контекст.
-->

---

## Copilot Instructions для BookingApp

```markdown
# BookingApp – Project Overview
...
## Tech Stack
Backend: Node.js + Express, MongoDB + Mongoose, JWT auth
Frontend: Plain HTML/CSS (Bootstrap), Vanilla JS
...
## Code Guidelines
- Modern ES6+ syntax
- TypeScript (.ts) with JSDoc
- ESLint (Airbnb style), 2 spaces indentation
```

<!--
Цей файл охоплює все важливе: функціонал, стек, стиль коду, структуру папок. Copilot буде краще розуміти контекст і генерувати релевантний код. Можна просити Copilot допомогти написати цей файл - мета-підхід, який рекомендують розробники.
-->

---

## Використання Copilot при написанні коду

<v-clicks>

1. Створення нового модуля: пишіть сигнатуру + коментар функції
2. Copilot пропонує реалізацію автоматично
3. Генерація тестів: Copilot Chat для реалізації тесту
4. Вирішення помилок: Chat допоможе діагностувати

</v-clicks>

<!--
Коментарій, описуючи функцію, дозволяє Copilot згенерувати кодовий каркас, що відповідає вашим вимогам. Це економить час на писанину типового коду. Тести можна генерувати через Chat, особливо для складних сценаріїв.
-->

---

## Приклад: cancelBooking функція

```typescript
/**
 * Cancels a booking by its ID if it belongs to the authenticated user.
 * - Verifies JWT and user identity
 * - Checks if booking exists and not already canceled
 * - Marks as canceled and frees the slot
 */
export async function cancelBooking(req: Request, res: Response) {
  // Copilot генерує реалізацію
}
```

<!--
Після цього Copilot пропонує повну реалізацію: try/catch блок, знаходження booking, перевірки, оновлення статусу, обробку помилок. Розробник перевіряє - код майже готовий, потрібні лише дрібні правки.
-->

---

## Best practices: визначення правил

<v-clicks>

- Витратьте час на створення файлу інструкцій з самого початку
- Чітко задокументуйте проект, стиль, очікування
- AI отримує "institutional knowledge" про проект
- Це основа для релевантних відповідей

</v-clicks>

<!--
Це перший крок до продуктивної роботи з AI. Навіть неповний файл інструкцій дасть помітний ефект. Потім його можна покращувати поступово, по мірі розвитку проекту.
-->

---

## Best practices: налаштування

<v-clicks>

- Налаштуйте середовище один раз - вигравайте постійно
- Інтеграція API-ключів, режими, auto-approve - важливі
- Правильно сконфігурований IDE дозволить зосередитися на творчості
- Делегуйте рутину агентам

</v-clicks>

<!--
Перше налаштування займе час, але потім кожен новий таск вирішується швидше. Дозолите агентам виконувати дрібні правки, обробку помилок, ініціалізацію об'єктів - це де AI сяє.
-->

---

## Best practices: промптинг

<v-clicks>

- Промпт-інжиніринг - новий скіл розробника
- Пробуйте різні формулювання, порівнюйте результати
- Діліться вдалими прийомами в команді
- Постійно вчіться

</v-clicks>

<!--
Запит "Explain X" інколи дає кращу відповідь, ніж "What is X?". Порядок слів, контекст, конкретність - все має значення. Обмінюйтеся знаннями про ефективні промпти в команді.
-->

---

## Best practices: контроль якості

<v-clicks>

- AI генерує чернетки, людина затверджує
- Обов'язковий code review, тестування, аналіз безпеки
- Ваша експертиза - остання інстанція
- Іноді агент заходить в тупик - потрібне втручання

</v-clicks>

<!--
Це критично важливо. AI не є заміною розробнику - це помічник. Особливо для Roo Code, який автономніший, потрібна людська думка для перевірки логіки та безпеки.
-->

---

## Best practices: оновлення

<v-clicks>

- Проект еволюціонує - оновлюйте правила
- Додаєте нову бібліотеку - відобразіть це в інструкціях
- AI помиляється в якомусь аспекті - додайте поясненням правило
- Гнучкість і вдосконалення - запорука довгострокової ефективності

</v-clicks>

<!--
Правила та навички мають жити в проекті, як документація. Не залишайте їх неактуальними. Якщо помітите систематичну помилку - додайте явне правило, і вона зникне.
-->

---

## Best practices: спільна база знань

<v-clicks>

- AI-конфігурації повинні бути доступні команді
- Включайте в репозиторій (крім секретних ключів)
- Документуйте в README, які skills та команди є
- Заохочуйте колег пропонувати нові

</v-clicks>

<!--
Це робить використання AI командним, не індивідуальним. Якби у вас з'явився новий співробітник, усі рівномірно взаємодіють з ним. Те саме з AI - спільна база знань вирівнює процес.
-->

---

## Best practices: безпека та етика

<v-clicks>

- AI може генерувати код, що порушує ліцензію (рідко)
- Не передавайте чутливий код в сторонні API без дозволу
- Для закритих проектів обирайте моделі з підтримкою конфіденційності
- Використовуйте AI відповідально

</v-clicks>

<!--
Roo Code зберігає дані локально - можна перевірити, що код не відправляється нікуди. Copilot for Business має toggle "do not retain code snippets". Завжди перевіряйте політику компанії щодо передачі коду третім сторонам.
-->

---

## Підсумок: три ключові моменти

<v-clicks>

1. **Правила** - це вартий інвестувати час. Гарні правила роблять AI ефективнішим.
2. **Навички** - вирішають "засмічення контексту". Використовуйте їх для спеціалізованих завдань.
3. **Команди** - стандартизують роботу. Поділіться в команді для консистентності.

</v-clicks>

<!--
Ці три компоненти - основа Agentic IDE. Разом вони дозволяють розробникам працювати з AI більш ефективно та безпечно. Це не одна велика налаштування - це цілісна система для управління AI в IDE.
-->

---

## Наступні кроки

<v-clicks>

1. Установіть Roo Code або GitHub Copilot (або обидва)
2. Напишіть файл правил для вашого проекту
3. Спробуйте режими та промпти
4. Створіть кілька навичок для спеціалізованих завдань
5. Поділіться налаштуваннями з командою

</v-clicks>

<!--
Починайте з малого. Напишіть базовий файл правил - це дасть найбільший ROI. Потім добавляйте навички та команди поступово. За кілька днів у вас буде добре налаштована Agentic IDE, яка прискорить розробку.
-->

---

## Ресурси

<v-clicks>

- [Roo Code GitHub](https://github.com/RooCode/roode) - документація та приклади
- [GitHub Copilot Docs](https://docs.github.com/en/copilot) - офіційна документація
- [Prompt Engineering Guide](https://www.promptingguide.ai/) - промпт-інжиніринг
- Це вам - PRD з більш детальною інформацією

</v-clicks>

<!--
Ресурси можна шукати в лінках. Документація обох інструментів постійно оновлюється. Спільнота Roo Code вже створила багато шаблонів режимів та навичок - можна брати готові рішення.
-->

---

## Запитання?

Дякуємо за увагу!

<!--
Слайди закінчилися. Тепер можете показувати практичні приклади, запускаючи Roo Code чи Copilot, демонструючи режими та команди в дії.
-->
